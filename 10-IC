(parenthesis)

<intar.l>
%{
#include "intar.tab.h"
#include <string.h>
#define strdup _strdup
%}

digit   [0-9]
letter  [a-zA-Z]

%%
{letter}({letter}|{digit})*   { yylval.sval = strdup(yytext); return ID; }
{digit}+(\.{digit}+)?         { yylval.sval = strdup(yytext); return NUM; }
[ \t]                         ;
\n                            ;
.                             { return yytext[0]; }
%%

int yywrap(void) { return 1; }


______<intar.y>______________
%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

int yylex(void);
void yyerror(const char *s);

int temp_count = 0;
char temp[10];

void codegen(char *op);
void codegen_assign(char *id);
void codegen_umin();
void push(char *text);

char stack[100][10];
int top = -1;
%}

%union {
    char *sval;
}

%token <sval> ID NUM
%left '+' '-'
%left '*' '/'
%right UMINUS
%type <sval> S E T F

%%

S : ID '=' E { codegen_assign($1); }
  ;

E : E '+' T { codegen("+"); }
  | E '-' T { codegen("-"); }
  | T
  ;

T : T '*' F { codegen("*"); }
  | T '/' F { codegen("/"); }
  | F
  ;

F : '(' E ')'
  | '-' F %prec UMINUS { codegen_umin(); }
  | ID { push($1); }
  | NUM { push($1); }
  ;

%%

int main(void) {
    printf("Enter the expression : ");
    yyparse();
    return 0;
}

void yyerror(const char *s) {
    fprintf(stderr, "Error: %s\n", s);
}

void push(char *text) {
    strcpy(stack[++top], text);
}

void codegen(char *op) {
    sprintf(temp, "t%d", temp_count++);
    printf("%s = %s %s %s\n", temp, stack[top-1], op, stack[top]);
    top--;
    strcpy(stack[top], temp);
}

void codegen_assign(char *id) {
    printf("%s = %s\n", id, stack[top]);
    top = -1;
    temp_count = 0;
}

void codegen_umin() {
    sprintf(temp, "t%d", temp_count++);
    printf("%s = -%s\n", temp, stack[top]);
    strcpy(stack[top], temp);
}


__________________terminal__________
bison -d -o intar.tab.c intar.y
flex intar.l
gcc intar.tab.c lex.yy.c -o intar.exe
.\intar.exe
________________________________

______________input__________________
Enter the expression : a=(k+8)*(c-s)

_output____
t0 = k + 8
t1 = c - s
t2 = t0 * t1
a = t2






_2-CONSTRUCTS_______________________

<progconst.l>
%{
#include "progconst.tab.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void yyerror(const char *s);
%}

letter  [a-zA-Z]
digit   [0-9]

%%

"if"        { return IF; }
"while"     { return WHILE; }
"else"      { return ELSE; }
"=="        { return EQ; }
"!="        { return NE; }
">="        { return GE; }
"<="        { return LE; }
">"         { return GT; }
"<"         { return LT; }
{letter}({letter}|{digit})*  { yylval.sval = strdup(yytext); return ID; }
{digit}+(\.{digit}+)?        { yylval.fval = atof(yytext); return NUM; }
";"         { return ';'; }
"="         { return '='; }
"+"         { return '+'; }
"-"         { return '-'; }
"*"         { return '*'; }
"/"         { return '/'; }
\(          { return '('; }
\)          { return ')'; }
"{"         { return '{'; }
"}"         { return '}'; }
[ \t\n]    ;
.          { return yytext[0]; }

%%
int yywrap() { return 1; }


<progconst.y>
%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int temp_count = 0;
int label_count = 0;

typedef struct {
    char code[50];
} IC;

IC gen_temp() {
    IC t;
    sprintf(t.code, "t%d", temp_count++);
    return t;
}

IC gen_label() {
    IC l;
    sprintf(l.code, "L%d", label_count++);
    return l;
}

void codegen_assign(char *lhs, IC rhs) {
    printf("%s = %s\n", lhs, rhs.code);
}

void codegen_op(IC result, IC op1, char operator, IC op2) {
    printf("%s = %s %c %s\n", result.code, op1.code, operator, op2.code);
}

void yyerror(const char *s) {
    printf("Error: %s\n", s);
}
%}

%union {
    char *sval;
    float fval;
    IC ic;
}

%token <sval> ID
%token <fval> NUM
%token IF ELSE WHILE
%token EQ NE GE LE GT LT
%type <ic> expr stmt

%%

program:
        | program stmt
        ;

stmt:
        ID '=' expr ';'   { codegen_assign($1, $3); }
    | IF '(' expr ')' '{' program '}'  { 
            IC label1 = gen_label();
            printf("if %s goto %s\n", $3.code, label1.code);
            printf("goto END_IF_%d\n", label_count);
            printf("%s:\n", label1.code);
        }
    | WHILE '(' expr ')' '{' program '}' {
            IC label_start = gen_label();
            IC label_end = gen_label();
            printf("%s:\n", label_start.code);
            printf("if %s goto %s\n", $3.code, label_end.code);
            // body statements will print inside program
            printf("%s:\n", label_end.code);
        }
    ;

expr:
        NUM       { $$ = gen_temp(); printf("%s = %.2f\n", $$ .code, $1); }
    |   ID        { $$ = gen_temp(); printf("%s = %s\n", $$ .code, $1); }
    | expr '+' expr { $$ = gen_temp(); codegen_op($$, $1, '+', $3); }
    | expr '-' expr { $$ = gen_temp(); codegen_op($$, $1, '-', $3); }
    | expr '*' expr { $$ = gen_temp(); codegen_op($$, $1, '*', $3); }
    | expr '/' expr { $$ = gen_temp(); codegen_op($$, $1, '/', $3); }
    | '(' expr ')'  { $$ = $2; }
    ;

%%

int main() {
    printf("Enter your program (end with Ctrl+Z / Ctrl+D):\n");
    yyparse();
    return 0;
}


______terminal_______
bison -d -o progconst.tab.c progconst.y
flex progconst.l
gcc progconst.tab.c lex.yy.c -o progconst.exe
.\progconst.exe
